#+TITLE: ASM-GP: Assembly Genetic Programming
#+OPTIONS: num:nil ^:nil
#+LaTeX_CLASS: normal
#+STARTUP: hideblocks

* ASM-GP
  :PROPERTIES:
  :j-file:   index
  :END:
** Introduction
This work uses Evolutionary Computation (EC) to evolve the assembly
(ASM) code compiled from existing programs with the goal of fixing
bugs in the original source code.

All [[file:code.org::gp-operations][GP Operations]] operate directly on the level of the assembly code
with no intermediate representation.

Unit tests from the original program are used to assess the fitness of
evolved variants and determine when the bug has successfully been
repaired.

This project is implemented entirely in [[http://clojure.org][clojure]], a lisp which runs on
the Java Virtual Machine and has a robust infrastructure for
multithreaded programming.

This page is intended to enable reproduction of this work.  Both the
[[file:code.org][source code]] and [[file:instructions.org][instructions for reproduction]] are provided.

* Code
  :PROPERTIES:
  :results:  silent
  :session:  asm-gp
  :tangle:   src/asm-gp.clj
  :j-file:   code
  :comments: no
  :ID:       2c73652b-b0aa-4770-b431-e58f558a0bd5
  :END:
To use this code, evaluate this subtree in your Clojure repl.
1) tangle out a clojure file by calling `org-babel-tangle'
2) load the file in your repl
   #+begin_src clojure :tangle no
     (load-file "src/asm-gp.clj")
     (in-ns 'asm-gp)
   #+end_src
3) follow the steps described in the [[file:instructions.org][instructions]]

** Namespace and included libraries
   :PROPERTIES:
   :ID:       6704f70c-b95e-4085-bf4e-f17c351fd01d
   :END:
#+begin_src clojure
  (ns asm-gp
      (:require (clojure.contrib
                 (duck-streams :as f)
                 (shell-out :as s))
                (clojure.contrib.generic (math-functions :as m)))
      (:import (java.io BufferedReader InputStreamReader File)
               (java.util ArrayList Collections)))
#+end_src

** Utility functions
   :PROPERTIES:
   :CUSTOM_ID: utility-functions
   :END:

*** macros
    :PROPERTIES:
    :ID:       ddde78da-0567-4ae9-802f-41f289ed87aa
    :END:

#+begin_src clojure
(defmacro while-let
  "Like while, but uses when-let instead of when."
  [test & body]
  `(loop []
     (when-let ~test
       ~@body
       (recur))))
#+end_src

a =message= function like in elisp
#+begin_src clojure
  (defn message
    [fmt & args]
    (println (apply format (cons fmt args))))
#+end_src

timeout long-running commands
#+begin_src clojure
  (defmacro with-timeout [ms & body]
    `(let [f# (future ~@body)]
       (.get f# ~ms java.util.concurrent.TimeUnit/MILLISECONDS)))
#+end_src

*** simple
tiny little functions
#+begin_src clojure
  (defn abs [n] (if (neg? n) (- 0 n) n))
#+end_src

*** edit distance
#+begin_src clojure
  (declare edit-distance)
  (defn cost "Return the difference between two assembly lines." [a b]
    (if (= a b)
      0
      (if (and (string? a) (string? b))
        (edit-distance (seq a) (seq b))
        1)))
#+end_src

This function is adapted largely unchanged from
http://www.fatvat.co.uk/2009/05/levenshtein-distance-in-clojure-ii.html
#+begin_src clojure
  (defn edit-distance-int
    "Calculates the edit-distance between two sequences"
    [seq1 seq2]
    (cond
     (empty? seq1) (count seq2)
     (empty? seq2) (count seq1)
     :else (min
            (+ (cost (first seq1) (first seq2))
               (edit-distance (rest seq1) (rest seq2))) ;; substitution
            (inc (edit-distance (rest seq1) seq2))    ;; insertion
            (inc (edit-distance seq1 (rest seq2)))))) ;; deletion
  
  (def edit-distance (memoize edit-distance-int))
#+end_src

*** serialization
    :PROPERTIES:
    :ID:       6ea5f5f7-1e96-4011-bc5a-92a3bcb72e63
    :END:
- write an object to a file
  #+begin_src clojure
    (defn write-obj
      "Write a clojure object to a file" [f obj]
      (f/spit f (pr-str obj)))
  #+end_src
- read an object from a file
  #+begin_src clojure
    (defn read-obj
      "Read a clojure object from a file" [f]
      (with-in-str (slurp f) (read)))
  #+end_src

*** random/weighted list access
    :PROPERTIES:
    :ID:       5912c566-6ed6-400e-9f4d-0c22b03fb358
    :END:
#+begin_src clojure
  (defn shuffle
    "Shuffles coll using a Java ArrayList." [coll]
    (let [l (ArrayList. coll)] (Collections/shuffle l) (seq l)))
  
  (defn place
    "Pick a random location from a sequence"
    [lst]
    (rand-int (count lst)))
  
  (defn pick
    "Pick and return a random element from a sequence."
    [lst] (nth lst (place lst)))
  
  (def point-neighborhood 4)
  
  (defn points-around
    "Return points in FROM located around POINT, ensure an even balance."
    ([from point] (points-around from point point-neighborhood))
    ([from point neighborhood]
       (let [neigh (apply min
                          (map abs
                               (list neighborhood point
                                     (- (count from) point))))]
         (take (+ 1 (* 2 neigh)) (drop (- point neigh) from)))))
  
  (defn weighted-place
    "Pick a random location in an asm individual weighted by the
     associated bad-path."
    ([asm] (weighted-place asm :bad-weight))
    ([asm weight-key]
       (pick
        ((fn [index asm assoc] ;; expand each place by it's weight
           (if (empty? asm)
             assoc
             (recur
              (inc index)
              (rest asm)
              (concat (repeat (m/ceil (or (weight-key (first asm)) 0)) index)
                      assoc))))
         0 asm (range (count asm))))))
  
  (defn weighted-pick
    "Return a random element in an asm individual weighted by the
     associated bad-path"
    ([asm]
       (nth asm (weighted-place asm)))
    ([asm weight-key]
       (nth asm (weighted-place asm weight-key))))
  
  (defn homologous-place
    "Return point in FROM whose surroundings are most like EXEMPLAR."
    [from exemplar]
    (let [neigh (/ (- (count exemplar) 1) 2)
          minima
          (loop [index neigh
                 closest nil
                 accum '()
                 remaining (drop neigh from)]
            (if (empty? (rest remaining))
              accum
              ;; sliding window from the front of the program, forward.
              (let [window (points-around from index neigh)
                    diff (edit-distance window exemplar)]
                (if (= diff 0)
                  ;; if hit zero, then abort and use that place
                  (list (list index 0))
                  ;; for each place, find the edit distance against the
                  ;; exemplar
                  (recur
                   (inc index)
                   (min diff (or closest diff))
                   (if (< diff (or closest diff))
                     (list (list index diff))
                     (cons (list index diff) accum))
                   (rest remaining))))))]
      ;; randomly choose one of the minima
      (if (empty? minima) (place from) (first (pick minima)))))
#+end_src

*** reading and writing assembly
    :PROPERTIES:
    :ID:       c883281f-48ec-4301-80b0-fc2b48146230
    :END:
#+begin_src clojure
  (defn read-asm
    "Read in an assembly file as list and parse cmd lines."
    [path]
    {:representation
     (map (fn [el]
            {:line (if-let [part (re-matches #"\t(.*)\t(.*)" el)]
                     (rest part)
                     el)})
          (f/read-lines path))
     :compile nil :fitness nil :trials nil :operations nil})

  (defn write-asm
    [f asm]
    (f/write-lines
     (f/file-str f)
     (map #(let [line (:line %)]
             (if (not (string? line))
               (apply str "\t" (interpose "\t" line)) line))
          (:representation asm))))
#+end_src

** Parameters
   :PROPERTIES:
   :CUSTOM_ID: parameters
   :END:

#+begin_src clojure
  (def target-fitness 10)
  (def max-generations 10)
  (def population-size 40)
  (def tournament-size 3)
  (def use-tournament false)
  (def max-section-size 1)
  (def crossover-rate 0.1)
  (def sticky-crossover-rate 0.75)
  (def fitness-cache-path
       (.getPath (f/file-str "~/research/code/data/fitness-cache.clj")))
  (def good-mult 1)
  (def bad-mult 5)
  (def compiler "gcc")
  (def compiler-flags nil) ;; (list "-pthread")
  (def test-dir nil)  ;; "~/research/code/gcd/"
  (def test-timeout 2000)
  (def test-good nil) ;; "./test-good.sh"
  (def test-bad nil)  ;; "./test-bad.sh"
  (def java-class-nest nil)
#+end_src

** Weighted Path
   :PROPERTIES:
   :CUSTOM_ID: assembly-manipulation
   :END:
*** read a path
    :PROPERTIES:
    :ID:       71b8ce66-5b52-409f-b338-74e39f6849a8
    :END:
#+begin_src clojure
  (defn read-path
    "Read the given path giving the raw sum of the value for each
    instruction."  [path-to-path]
    (reduce
     (fn [a f] (assoc a f (inc (get a f 0)))) {}
     (map (fn [arg] (Integer/parseInt arg))
          (f/read-lines path-to-path))))
#+end_src

*** smooth path
    :PROPERTIES:
    :ID:       c658d230-db3c-43f0-92be-a3a42023e8ca
    :END:
smooth out the weight of a good/bad path
#+begin_src clojure
  (defn smooth-path
    "Smooth the given path by blurring with a 1-D Gaussian, then taking
    the log of all values -- with a min value of 1 for each
    instruction."  [path]
    (let [kernel {-3 0.006, -2 0.061, -1 0.242, 0 0.383, 1 0.242, 2 0.061, 3 0.006}]
      ;; log of the blurred weights
      (reduce
       (fn [accum el] (assoc accum (first el) (m/log (inc (second el))))) {}
       ;; 1D Gaussian Smoothing of weights
       (reduce
          (fn [accum el]
            (reduce
             (fn [a f]
               (let [place (+ (first el) (first f))]
                 (assoc a place
                        (+ (get a place 0)
                           (* (second f) (second el))))))
             accum kernel)) {}
             path))))
#+end_src

*** difference between paths
    :PROPERTIES:
    :ID:       5034668b-9dc4-4130-8d54-533b49ba2832
    :END:
#+begin_src clojure
  (defn path-
    "Subtract one path from another." [left right]
    (reduce (fn [l r] (dissoc l (first r))) left right))
#+end_src

*** apply path
    :PROPERTIES:
    :ID:       0213ca00-f446-45b3-8d1b-ad9b3df53239
    :END:
Apply the weights in a good or bad path to a GP individual
#+begin_src clojure
  (defn apply-path
    "Apply the weights in a path to a GP individual"
    [asm key path]
    (assoc asm
      :representation
      (reduce #(let [place (first %2) weight (second %2)]
                 (if (< place (count %1))
                   (concat
                    (take place %1)
                    (list (assoc (nth %1 place) key weight))
                    (drop (inc place) %1))
                   %1)) (:representation asm) path)))
#+end_src

** GP Operations
   :PROPERTIES:
   :CUSTOM_ID: gp-operations
   :END:

#+begin_src clojure
  (defn section-length
    "Limit the size of sections of ASM used for GP operations."
    [single length]
    (if single
      (if (number? single) (min single length) 1)
      (inc (rand-int (min max-section-size length)))))
#+end_src

*** swap-asm
    :PROPERTIES:
    :ID:       c6df8054-1055-45c5-b689-b4472f07d7ec
    :END:
#+begin_src clojure
  (defn swap-asm
    "Swap two lines or sections of the asm."
    ([asm] (swap-asm asm nil))
    ([asm single]
       (assoc asm
         :representation
         (if (empty? asm)
           asm
           (let [asm (:representation asm)
                 first (weighted-place asm)
                 second (weighted-place asm)]
             (if (= first second)
               asm
               (let [left (min first second)
                     right (max first second)
                     left-length
                     (section-length single
                                     (count (take (- right left) (drop left asm))))
                     right-length (section-length single (count (drop right asm)))]
                 (concat
                  (take left asm)
                  (take right-length (drop right asm))
                  (take (- right (+ left left-length))
                        (drop (+ left left-length) asm))
                  (take left-length (drop left asm))
                  (drop (+ right right-length) asm))))))
         :operations (cons :swap (:operations asm)))))
#+end_src

*** delete-asm
    :PROPERTIES:
    :ID:       33dbf594-fc55-44c7-8477-6bd1a520f95a
    :END:
delete a section
#+begin_src clojure
  (defn delete-asm
    "Delete a line or section from the asm.  Optional second argument
  will force single line deletion rather than deleting an entire
  section."
    ([asm] (delete-asm asm nil))
    ([asm single]
       (assoc asm
         :representation
         (if (empty? asm)
           asm
           (let [asm (:representation asm)
                 start (weighted-place asm)
                 length (section-length single (count (drop start asm)))]
             (concat (take start asm) (drop (+ start length) asm))))
         :operations (cons :delete (:operations asm)))))
#+end_src

*** append-asm
    :PROPERTIES:
    :ID:       42a5c988-1d2c-4571-89f8-7f5dd4144d31
    :END:
append a section or line into a random place
#+begin_src clojure
  (defn append-asm
    "Inject a line from the asm into a random location in the asm.
    Optional third argument will force single line injection rather than
    injecting an entire section."
    ([asm] (append-asm asm nil))
    ([asm single]
       (assoc asm
         :representation
         (if (empty? asm)
           asm
           (let [asm (:representation asm)
                 start (weighted-place asm :good-weight)
                 length (section-length single (count (drop start asm)))
                 point (weighted-place asm)]
             (concat (take point asm) (take length (drop start asm))
                     (drop point asm))))
         :operations (cons :append (:operations asm)))))
#+end_src

*** mutate-asm
    :PROPERTIES:
    :ID:       60ae1744-f49e-4b0a-a1d1-702d703823cf
    :END:
which here means either delete, append, or swap
#+begin_src clojure
  (defn mutate-asm
    "Mutate the asm with either delete-asm, append-asm, or swap-asm.
    For now we're forcing all changes to operate by line rather than
    section." [asm]
    (let [choice (rand-int 3)]
      (cond
       (= choice 0) (delete-asm asm)
       (= choice 1) (append-asm asm)
       (= choice 2) (swap-asm asm))))
#+end_src

*** crossover-asm
    :PROPERTIES:
    :ID:       beb50995-dcf1-4612-848c-7808164be4ac
    :END:
Two point crossover between two individuals.  Will be /sticky/ with
probability =sticky-crossover-rate=.
#+begin_src clojure
  (defn crossover-sticky-asm
    "Takes two individuals and returns the result of performing single
    point crossover between then."  [mother father]
    {:representation
     (if (empty? mother)
       (if (empty? father)
         '()
         father)
       (if (empty? father)
         mother
         (let [mother (:representation mother) father (:representation father)]
           ;; sticky crossover -- does taking a mid-point first bias things?
           (let [mid (weighted-place mother)
                 mother-l (take mid mother) mother-r (drop mid mother)
                 father-l (take mid father) father-r (drop mid father)
                 mid-l (when (not (empty? mother-l)) (weighted-place mother-l))
                 mid-r (when (not (empty? mother-r)) (weighted-place mother-r))]
             (concat (if mid-l (take mid-l mother-l) '())
                     (if mid-l (drop mid-l father-l) '())
                     (if mid-r (take mid-r father-r) '())
                     (if mid-r (drop mid-r mother-r) '()))))))
     :operations (list :crossover
                       (list (:operations mother)
                             (:operations father)))
     :compile nil :fitness nil :trials (max (get :trials mother 0)
                                            (get :trials father 0))})
#+end_src

#+begin_src clojure
  (defn crossover-normal-asm
    "Takes two individuals and returns the result of performing single
    point crossover between then."  [mother father]
    {:representation
     (if (empty? mother)
       (if (empty? father)
         '()
         father)
       (if (empty? father)
         mother
         (let [mother (:representation mother) father (:representation father)]
           ;; traditional 2-point crossover
           (let [mid-m (weighted-place mother)
                 mid-f (weighted-place father)
                 mother-l (take mid-m mother) mother-r (drop mid-m mother)
                 father-l (take mid-f father) father-r (drop mid-f father)
                 mid-ml (when (not (empty? mother-l)) (weighted-place mother-l))
                 mid-mr (when (not (empty? mother-r)) (weighted-place mother-r))
                 mid-fl (when (not (empty? father-l)) (weighted-place father-l))
                 mid-fr (when (not (empty? father-r)) (weighted-place father-r))]
             (concat (if mid-ml (take mid-ml mother-l) '())
                     (if mid-fl (drop mid-fl father-l) '())
                     (if mid-fr (take mid-fr father-r) '())
                     (if mid-mr (drop mid-mr mother-r) '()))))))
     :operations (list :crossover
                       (list (:operations mother)
                             (:operations father)))
     :compile nil :fitness nil :trials (max (get :trials mother 0)
                                            (get :trials father 0))})
#+end_src

#+begin_src clojure
  (defn crossover-homologous-asm
    "Takes two individuals and returns the result of performing single
    point crossover between then."  [mother father]
    {:representation
     (if (empty? mother)
       (if (empty? father)
         '()
         father)
       (if (empty? father)
         mother
         (let [mother (:representation mother) father (:representation father)]
           ;; homologous -- similar instructions
           ;; 
           ;; 1) pick two spots in mother
           ;; 2) find similar spots in father
           ;; 3) proceed with normal combination method
           ;; 
           (let [mid-m (weighted-place mother)
                 ;; 1
                 mother-l (take mid-m mother) mother-r (drop mid-m mother)
                 mid-ml (if (empty? mother-l) 0 (weighted-place mother-l))
                 exemplar-l (when mid-ml (points-around mother-l mid-ml))
                 mid-mr (if (empty? mother-r) 0 (weighted-place mother-r))
                 exemplar-r (points-around mother-l mid-mr)
                 ;; 2
                 mid-fl (homologous-place father exemplar-l)
                 father-l (take mid-fl father)
                 father-remainder (drop (- mid-fl (/ (- (count exemplar-r) 1) 2))
                                        father)
                 mid-fr (if (not (empty? father-remainder))
                          (homologous-place father-remainder exemplar-r))
                 father-r (drop mid-fr father-remainder)]
             ;; 3
             (concat (if mid-ml (take mid-ml mother-l) '())
                     (if mid-fl (drop mid-fl father-l) '())
                     (if mid-fr (take mid-fr father-r) '())
                     (if mid-mr (drop mid-mr mother-r) '()))))))
     :operations (list :crossover
                       (list (:operations mother)
                             (:operations father)))
     :compile nil :fitness nil :trials (max (get :trials mother 0)
                                            (get :trials father 0))})
#+end_src

*** compile-asm
    :PROPERTIES:
    :ID:       94a14915-ae18-4ab3-884c-9f717690416b
    :END:
#+begin_src clojure
  (defn compile-asm
    "Compile the asm, set it's :compile field to the path to the
    compiled binary if successful or to nil if unsuccessful."  [asm]
    (let [asm-source (.getPath (File/createTempFile "variant" ".S"))
          asm-bin (.getPath (File/createTempFile "variant" "bin"))]
      (write-asm asm-source asm)
      (assoc asm
        :compile
        (when (= 0 (:exit
                    (apply
                     s/sh
                     (concat
                      (apply list compiler compiler-flags)
                      (list "-o" asm-bin asm-source :return-map true)))))
          (s/sh "chmod" "+x" asm-bin)
          asm-bin))))
#+end_src

** Fitness Evaluation
   :PROPERTIES:
   :ID:       44042354-a94e-43f3-936b-65d50bf0b136
   :END:
We'll cache already calculated finesses in a global hash which is
protected behind a [[http://clojure.org/refs][ref]].
#+begin_src clojure
  (def fitness-cache (ref {}))
#+end_src

We'll track the total number of fitness evaluations in a global
counter also protected behind a ref.
#+begin_src clojure
  (def fitness-count (ref 0))
#+end_src

#+begin_src clojure
  (defn evaluate-asm
    "Take an individual, evaluate it and pack it's score into
    it's :fitness field."  [asm]
    ;; increment our global fitness counter
    (dosync (alter fitness-count inc))
    (assoc
        ;; evaluate the fitness of the individual
        (if (@fitness-cache (.hashCode (:representation asm)))
          (assoc asm ;; cache hit
            :fitness (@fitness-cache (.hashCode (:representation asm)))
            :compile true)
          (let [asm (compile-asm asm) ;; cache miss
                test-good (.getPath (f/file-str test-dir test-good))
                test-bad (.getPath (f/file-str test-dir test-bad))
                bin (:compile asm)
                run-test (fn [test mult]
                           (* mult
                              (try
                               (let [out-file (.getPath (File/createTempFile "variant" ".out"))]
                                 (with-timeout test-timeout (s/sh test bin out-file))
                                 (count (f/read-lines out-file)))
                               (catch java.util.concurrent.TimeoutException e 0))))]
            (assoc asm
              :fitness ((dosync (alter fitness-cache assoc (.hashCode
                                                            (:representation asm))
                                       (if bin ;; new fitness
                                         (+ (run-test test-good good-mult)
                                            (run-test test-bad bad-mult))
                                         0)))
                        (.hashCode (:representation asm))))))
      :trials @fitness-count))
#+end_src

** Evolution
*** populate
    :PROPERTIES:
    :ID:       8078113f-c63b-4a22-93e5-233a2b5d811c
    :END:
#+begin_src clojure
  (defn populate
    "Return a population starting with a baseline individual.
    Pass :group true as optional arguments to populate from a group of
    multiple baseline individuals."
    [asm & opts]
    ;; this doesn't work as list? will return true no matter what, we
    ;; must use an optional keyword argument...
    (let [asm (if (get (apply hash-map opts) :group false)
                asm (list asm))]
      ;; calculate their fitness
      (pmap #(evaluate-asm %)
            ;; include the originals
            (concat asm
                    ;; create random mutants
                    (take (- population-size (count asm))
                          (repeatedly #(mutate-asm (pick asm))))))))
#+end_src

*** selection -- tournament and sus
    :PROPERTIES:
    :ID:       559201d3-d9c4-4088-b878-6fae85d0df20
    :END:
tournament selection
#+begin_src clojure
  (defn tournament
    "Select an individual from the population via tournament selection."
    [population n]
    (take n
          (repeatedly
           (fn []
             (last
              (sort-by :fitness
                       (take tournament-size
                             (repeatedly #(pick population)))))))))
#+end_src

Stochastic universal Sampling (see [[wiki:Stochastic_universal_sampling]])
#+begin_src clojure
  (defn stochastic-universal-sample
    "Stochastic universal sampling"
    [population n]
    (let [total-fit (reduce #(+ %1 (:fitness %2)) 0 population)
          step-size (/ total-fit n)]
      (loop [pop (reverse (sort-by :fitness (shuffle population)))
             accum 0 marker 0
             result '()]
        (if (> n (count result))
          (if (> marker (+ accum (:fitness (first pop))))
            (recur (rest pop) (+ accum (:fitness (first pop))) marker result)
            (recur pop accum (+ marker step-size) (cons (first pop) result)))
          result))))
#+end_src

#+begin_src clojure
  (defn select-asm [population n]
    (if use-tournament
      (tournament population n)
      (stochastic-universal-sample population n)))
#+end_src

*** evolve
    :PROPERTIES:
    :ID:       8347689e-4fc3-4199-8884-35beae9afffa
    :END:
#+begin_src clojure
  (defn evolve
    "Build a population from a baseline individual and evolve until a
  solution is found or the maximum number of generations is reached.
  Return the best individual present when evolution terminates."
    [asm]
    (loop [population (populate asm)
           generation 0]
      (let [best (last (sort-by :fitness population))
            mean (/ (float (reduce + 0 (map :fitness population)))
                    (count population))]
        ;; write out the best so far
        (message "generation %d mean-score %S best{:fitness %S, :trials %d}"
                 generation mean (:fitness best) (:trials best))
        (write-obj (format "variant.gen.%d.best.%S.clj"
                           generation (:fitness best)) best)
        (if (>= (:fitness best) target-fitness)
          (do ;; write out the winner to a file and return
            (message "success after %d generations and %d fitness evaluations"
                     generation @fitness-count)
            (write-obj "best.clj" best) best)
          (if (>= generation max-generations)
            (do ;; print out failure message and return the best we found
              (message "failed after %d generations and %d fitness evaluations"
                       generation @fitness-count) best)
            (recur
             (select-asm
              (concat
               (dorun
                (pmap #(evaluate-asm %)
                      (concat
                       (take (Math/round (* crossover-rate population-size))
                             (repeatedly
                              (fn []
                                (apply crossover-normal-asm
                                       (select-asm population 2)))))
                       (pmap #(mutate-asm %)
                            (select-asm population
                                        (Math/round (* (- 1 crossover-rate)
                                                       population-size)))))))
               population)
              population-size)
             (+ generation 1)))))))
#+end_src
** Java Byte-Code Functions
    :PROPERTIES:
    :tangle:   src/bytecode-gp.clj
    :ID:       fece78b7-5b8c-4510-bffa-f46d73896971
    :END:

in the asm-gp name-space
#+begin_src clojure
  (in-ns 'asm-gp)
  (import '(org.apache.bcel.classfile ClassParser)
          '(org.apache.bcel.generic ClassGen MethodGen InstructionList))
#+end_src

introducing a new global variable to hold information needed to write
new byte-code strings to a =.class= file.
#+begin_src clojure
  (def base-class nil)
#+end_src

*** read-asm
    :PROPERTIES:
    :ID:       942ad66d-060e-4b79-80da-17b4d2cb5515
    :END:
new functions for reading and writing assembly files
#+begin_src clojure
  (defn read-asm
    "Read in a .class file to a list of Byte-code instructions.  For now
    we'll just be working with the main function." [path]
    {:representation
     (let [class (new ClassGen (.parse (new ClassParser path)))]
       (map
        (fn [meth]
          (.getInstructionList
           (new MethodGen
                meth
                (.getClassName class)
                (.getConstantPool class)))) (.getMethods class)))
     :compile nil :fitness nil :trials nil :operations nil})
#+end_src

*** write-asm
    :PROPERTIES:
    :ID:       1734877f-c8ed-40d6-949d-ef4675064f16
    :END:
#+begin_src clojure
  (defn write-asm
    "Write a list of Byte-code instructions to a file.  Return f if the
    write was successful, and nil otherwise." [f lst]
    (if (not base-class)
      (message "base class is uninitialized!"))
    (try
     (let [cls (new ClassGen base-class)]
       (map
        (fn [base lst]
          (let [mth (new MethodGen base
                         (.getClassName cls)
                         (.getConstantPool cls))]
            (.setPositions lst false)
            (.setInstructionList mth lst)
            (.setMaxStack mth)
            (.setMaxLocals mth)
            (.removeLineNumbers mth)
            (.replaceMethod cls base (.getMethod mth))))
        (.getMethods cls) (:representation lst))
       (.dump (.getJavaClass cls) f))
     f
     (catch Exception e nil)))
#+end_src

*** gp utility
    :PROPERTIES:
    :ID:       50820f90-e596-43d9-a421-dd83cab0d6cb
    :END:
wrap GP operations in try/catch blocks
#+begin_src clojure
  (defmacro gp-op-wrapper
    "Wrap a GP operation in a try/catch block which will return an empty
    InstructinoList if any errors are thrown while manipulating the
    individual."  [& body] `(try ~@body (catch Exception _# (InstructionList.))))
#+end_src

select places and instruction from lists of instruction lists
#+begin_src clojure
  (defn instrs-place
    "Return a random location from a list of instruction lists."
    [instrs]
    (let [meth_num (rand-int (count instrs))]
      (list meth_num (rand-int (count (nth instrs meth_num))))))

  (defn instrs-pick
    "Pick an instruction from a list of instruction lists."
    [instrs place]
    (nth (.getInstructionHandles (nth instrs (first place))) (second place)))
#+end_src

*** swap-asm
    :PROPERTIES:
    :ID:       d01c0b7a-902a-43e9-b84f-3725fe310888
    :END:
#+begin_src clojure
  (defn swap-asm
    "Swap two instructions in this InstructionList.  Not Weighted."
    ([asm _] (swap-asm asm))
    ([asm]
       (assoc asm
         :representation
         (gp-op-wrapper
          (let [asm (map #(.copy %) (:representation asm))
                left (instrs-place asm)
                right (instrs-place asm)]
            (message "%S" left) (message "%S" right)
            asm))
         :operations (cons :swap (:operations asm)))))
#+end_src

*** append-asm
    :PROPERTIES:
    :ID:       69ad68ea-6533-454d-847a-4f31f74be774
    :END:
#+begin_src clojure
  (defn append-asm
    "Append an instruction somewhere in this InstructionList.  Not
    Weighted.  Return a copy of the original if the operations fail."
    ([asm _] (append-asm asm))
    ([asm]
       (assoc asm
         :representation
         (gp-op-wrapper
          (let [asm (.copy (:representation asm))
                handles (seq (.getInstructionHandles asm))]
            (.append asm
                     (pick handles)
                     (.getInstruction (pick handles)))
            asm))
         :operations (cons :append (:operations asm)))))
#+end_src

*** delete-asm
    :PROPERTIES:
    :ID:       4a364d84-efc3-4750-9669-b235306e6e78
    :END:
#+begin_src clojure
  (defn delete-asm
    "Remove an instruction from list InstructionList.  Not Weighted"
    ([asm _] (delete-asm asm))
    ([asm]
       (assoc asm
         :representation
         (gp-op-wrapper
          (let [asm (.copy (:representation asm))
                handles (seq (.getInstructionHandles asm))]
            (.delete asm (pick handles))
            asm))
         :operations (cons :delete (:operations asm)))))
#+end_src

*** compile-asm
    :PROPERTIES:
    :ID:       04a68be1-a878-49ed-ad4f-9d53f553519c
    :END:
new fitness and compilation functions
#+begin_src clojure
  (defn compile-asm
    "Compile the asm and return a path to the resulting binary.  Return
    nil if the compilation (write) fails."  [asm]
    (let [asm-dir (str
                   (.getPath (File/createTempFile "variant" "")) "/"
                   (or java-class-nest ""))]
      (s/sh "rm" "-rf" asm-dir) (s/sh "mkdir" "-p" asm-dir)
      (assoc asm
        :compile
        (if (write-asm (str asm-dir "/" (.getClassName base-class) ".class") asm)
          asm-dir
          nil))))
#+end_src

** =modify= shell script
   :PROPERTIES:
   :ID:       6b8b61da-cbdf-42d9-bdc8-d681b6cb0ba8
   :END:

#+begin_src clojure :tangle scripts/modify.clj :shebang #! /usr/bin/env clj
  (load-file "/home/eschulte/research/genprog/asm/src/asm-gp.clj")
  (in-ns 'asm-gp)
  (require ['clojure.contrib.command-line :as 'cmd])
  (cmd/with-command-line (rest *command-line-args*)
    "Prototype No-Specification Machine-code-level Bug-Fixer\n\tmodify [opts] baseline.s"
    [[gcc         "use X to compile C files" "gcc"]
     [ldflags     "use X as LDFLAGS when compiling" nil]
     [good        "use X as good-test command" "./test-good.sh"]
     [bad         "use X as bad-test command" "./test-bad.sh"]
     [bad-factor  "multiply 'bad' testcases by X for utility" 5]
     [good-factor "multiply 'good' testcases by X for utility" 1]
     [sanity-test "sanity fitness of baseline individual"]
     [max         "best fitness possible is X" 10]
     [fit-cache   "path to the fitness cache"]
     [good-path   "file specifying the good path" "good.path"]
     [bad-path    "file specifying the good path" "bad.path"]
     [path-sub?   "subtract the good path from the bad path"]
     [pop         "use population size of X" 40]
     [gen         "use X genetic algorithm generations" 10]
     [cross-rate  "percentage of population generated through crossover" 0.1]
     [sticky-cross-rate "percentage crossover to be done stickily" 0]
     [tour?       "use tournament selection for sampling"]
     [tour-size   "tournament size" 3]
     [java?       "operate on a Java .class file"]
     [class-nest  "class directory nesting for java .class files"]
     rest]
  
    ;; ;; over-define some functions for working with Java .class files
    ;; (when java?
    ;;   (load-file "/home/eschulte/research/genprog/asm/src/bytecode-gp.clj"))
  
    ;; define GP parameters
    (let [to_int (fn [in] (if (string? in)
                            (Integer/parseInt in)
                            in))]
      (def target-fitness (to_int max))
      (def max-generations (to_int gen))
      (def population-size (to_int pop))
      (def use-tournament tour?)
      (def tournament-size (to_int tour-size))
      (def crossover-rate (if (string? cross-rate)
                            (Float/parseFloat cross-rate) cross-rate))
      (def sticky-crossover-rate
           (if (string? sticky-cross-rate)
             (Float/parseFloat sticky-cross-rate) sticky-cross-rate))
      (def good-mult (to_int good-factor))
      (def bad-mult (to_int bad-factor))
      (def compiler gcc)
      (def compiler-flags ldflags)
      (def test-dir "./")
      (def test-timeout 2000)
      (def test-good good)
      (def test-bad bad)
      (def java-class-nest class-nest))
  
    ;; save configuration to file
    (write-obj "config.clj"
               (list
                "target-fitness" max
                "max-generations" gen
                "population-size" pop
                "use-tournament" tour?
                "crossover-rate" crossover-rate
                "sticky-crossover-rate" sticky-crossover-rate
                "good-mult" good-factor
                "bad-mult" bad-factor
                "good-path" good-path
                "bad-path" bad-path
                "path-sub" path-sub?
                "compiler" gcc
                "compiler-flags" ldflags
                "test-dir" "./"
                "test-timeout" 2000
                "test-good" good
                "test-bad" bad))
  
    ;; run evolution
    (doseq [baseline-path rest]
      (let [fitness-cache (ref (if fit-cache (read-obj fit-cache) {}))
            good-path (if good-path (read-path good-path) nil)
            bad-path (if bad-path (read-path bad-path) nil)
            bad-path (if (and bad-path good-path path-sub?)
                       (path- bad-path good-path)
                       bad-path)
            baseline (apply-path
                      (apply-path
                       (read-asm baseline-path)
                       :good-path (smooth-path good-path))
                      :bad-path (smooth-path bad-path))]
        ;; (when java?
        ;;   (def base-class (.parse (new org.apache.bcel.classfile.ClassParser baseline-path))))
        ;; sanity check
        (when sanity-test
          (assert (= (:fitness (evaluate-asm baseline)) sanity-test)))
        (evolve baseline)
        (if fit-cache (write-obj fit-cache @fitness-cache)))))
#+end_src

* Instructions
  :PROPERTIES:
  :j-file:   instructions
  :ID:       6cdb4aaf-8c46-4bae-85a2-0e567baecadf
  :END:

The following steps can be followed to repair a buggy program at the
assembly level.  Not that this process involves the execution of
arbitrary assembly code, which can be *very* harmful.  It is
recommended that all of the following steps take place inside of a
virtual machine.

The following will operate upon a simple buggy implementation of
Euclid's algorithm for the greatest common divisor.  This will require
obtaining the code and support files, configuring a working clojure
instillation, performing fault localization to isolate buggy portions
of the ASM file, running evolution of new program variants until a
solution is found.

1) The source-code and all support files are available at
   [[file:asm-gp.tar.bz2][asm-gp.tar.bz2]].

2) See [[http://clojure.org/getting_started]] for information on
   configuring a working Clojure environment on your machine.

3) Once the code is installed on your machine, unpack the =gcd=
   directory.  This directory should include the following,
   #+begin_example
     $ ls gcd
     gcd.c        output.1071.1029     output.555.666  output.8767.653  test-good.sh
     output.0.55  output.16777216.512  output.678.987  test-bad.sh
   #+end_example
   including the buggy program (=gcd.c=), shell scripts for executing
   the good and bad test cases respectively (=test-good.sh=,
   =test-bad.sh=), and a number of files containing the correct output
   for various inputs (=output.*=).
   
   Compile the buggy program to assembly code using the [[http://gcc.gnu.org/][Gnu C Compiler]].
   : gcc -S gcd.c
   
   Compile an executable from the resulting assembly
   : gcc -o gcd gcd.s

4) Now install [[http://oprofile.sourceforge.net/news/][oprofile]], which will be used for fault localization.
   On Debian systems =oprofile= can be installed with
   : apt-get install oprofile

   First =oprofile= must be started with something like the following.
   : opcontrol --start
   
   Once started =oprofile= will begin taking samples of the program
   counter(s) in your machine.
   
   We will run both the /good/ and /bad/ test cases with
   =test-good.sh= and =test-bad.sh= respectively with =oprofile=
   running in the background.  After each of these runs we view the
   samples with
   : opannotate --assembly gcd

   the output of that command looks something like
   #+begin_example
        1  0.3257 : 804f318:       cmpl   $0x1,-0x10(%ebp)
        3  0.9772 : 804f31c:       je     804f323 <sgets+0x115>
                  : 804f31e:       negl   -0xc(%ebp)
                  : 804f321:       jmp    804f347 <sgets+0x139>
                  : 804f323:       addl   $0x1,-0xc(%ebp)
        1  0.3257 : 804f327:       mov    0x8(%ebp),%eax
                  : 804f32a:       movzbl (%eax),%eax
                  : 804f32d:       cmp    $0xa,%al
        1  0.3257 : 804f32f:       jne    804f337 <sgets+0x129>
                  : 804f331:       addl   $0x1,0x8(%ebp)
   #+end_example
   and will be usable for localizing good/bad behavior to the specific
   assembly instructions in the assembly file (=gcd.s=).  The mapping
   from memory addresses to assembly instructions is generated using
   the =mem-mapping.clj= script included in the scripts directory
   distributed with this project.  This mapping is generated with the
   following command
   : clj ../mem-mapping.clj gcd.s gcd
   
   Putting this all together yields the following sequence of steps
   which should be performed for both the good and bad tests (good
   shown).
   1) stop the daemon
      : sudo opcontrol --shutdown
   2) clear out old information
      : sudo opcontrol --reset
   3) start up the daemon
      : sudo opcontrol --start
   4) run the good test 50 times
      #+begin_src sh
        for i in `seq 10`; do
            j=`expr $i - 1`
            ./test-good.sh ./null output 401$j
        done
      #+end_src
   5) convert the memory addresses to lines in the assembly file and
      save the results in the file =good.path=
      : opannotate --assembly null | clj ../opannotate-to-path.clj > good.path

5) Once the good and bad path files have been created the actual
   evolution of program variants can begin.  Once again it is worth
   mentioning that this step should be performed inside of a virtual
   machine as arbitrary assembly code will be executed, and will in
   all likelihood take actions which would be considered malicious one
   inclined to assign motives to artifacts of random mutation.
   
   The =modify.clj= script controls the entire evolution process.
   It's build-in help command should be sufficient to describe it's
   usage.  As with the rest of this project, everything should be
   considered to be in early alpha development, and the source-code is
   the ultimate form of documentation.
   #+begin_example
     $ modify.clj --help
     Prototype No-Specification Machine-code-level Bug-Fixer
             modify [opts] baseline.s
     Options
       --gcc <arg>          use X to compile C files                              [default gcc]           
       --ldflags <arg>      use X as LDFLAGS when compiling                                               
       --good <arg>         use X as good-test command                            [default ./test-good.sh]
       --bad <arg>          use X as bad-test command                             [default ./test-bad.sh] 
       --bad-factor <arg>   multiply 'bad' testcases by X for utility             [default 5]             
       --good-factor <arg>  multiply 'good' testcases by X for utility            [default 1]             
       --sanity-test <arg>  sanity fitness of baseline individual                                         
       --max <arg>          best fitness possible is X                            [default 10]            
       --fit-cache <arg>    path to the fitness cache                                                     
       --good-path <arg>    file specifying the good path                         [default good.path]     
       --bad-path <arg>     file specifying the good path                         [default bad.path]      
       --pop <arg>          use population size of X                              [default 40]            
       --gen <arg>          use X genetic algorithm generations                   [default 10]            
       --sect-size <arg>    mutate over sections of X instructions                [default 1]             
       --ins <arg>          relative chance of mutation insertion                 [default 1]             
       --del <arg>          relative chance of mutation deletion                  [default 1]             
       --swap <arg>         relative chance of mutation swap                      [default 1]             
       --cross-rate <arg>   percentage of population generated through crossover  [default 0.1]           
       --tour               use tournament selection for sampling                                         
       --tour-size <arg>    tournament size                                       [default 3]             
       --java               operate on a Java .class file                                                 
       --class-nest <arg>   class directory nesting for java .class files                                 
   #+end_example
   An example usage may look like the following.
   : nice modify.clj --tour --tour-size 3 --cross-rate 0.1 --pop 400 gcd.s
   
   After each generation the best individual will be written to a
   =.clj= file of Clojure source code.  These individuals can be
   loaded into a Clojure repl from which they can be inspected, and
   can be written to assembly files (see [[file:code.org::assembly-manipulation][Assembly Manipulation]] and
   [[file:code.org::utility-functions][Utility Functions]]).
   
* COMMENT Tasks [25/27]
** step by step for running through this whole process
   :PROPERTIES:
   :ID:       64e5c886-ed5f-4466-80e0-298cffd9d890
   :END:
1) compile to asm
   : gcc -S source.c
2) generate executable
   : gcc -o source source.s
3) generate memory mapping for good/bad paths
   : mem-mapping.clj source.s source
4) sample execution with =opannotate= for both the good and bad test cases
   1) stop the daemon
      : sudo opcontrol --shutdown
   2) clear out old information
      : sudo opcontrol --reset
   3) start up the daemon
      : sudo opcontrol --start
   4) run the [good/bad] test 100 times
      : for i in `seq 100`; do
      :     ./test-[good/bad].sh ./source /dev/null 2> /dev/null
      : done
   5) dump the annotations to lines in the assembly file and save the
      results in [good/bad].path
      : opannotate --assembly source\
      : | ../opannotate-to-path.clj > [good/bad].path
      if =opannotate= hasn't sampled any points it will print the
      following line
      : error: no sample files found: profile specification too strict ?
      in that case, re-run the previous step with an order of
      magnitude more iterations (e.g. =seq 1000= instead of =seq 100=)
5) turn off =opcontrol=
   : sudo opcontrol --shutdown
6) alright, the preparation is complete.  a single run can be
   performed with the following command
   : nice modify.clj --tour --tour-size 2 --pop 400 --cross-rate 0.1 source.s
   try
   : modify.clj help
   for more command line options.
   
   alternately a suite of 100 executions can be performed by first
   creating the variants directory
   : mkdir variants
   and then running using the =test-asm.sh= shell script.
   : test-asm.sh source.s

** path difference
   :PROPERTIES:
   :ID:       d451e88d-e7ff-4364-a6f5-c0b61fa35b19
   :END:

#+begin_src clojure
  (defn path-diff-at [base]
    (let [path-base (str "/home/eschulte/research/genprog-experiments/icse-experiments/"
                         base
                         "/")
          good-path (read-path (str path-base "good.path"))
          bad-path (read-path (str path-base "bad.path"))]
      (/ (- (count (keys bad-path)) (count (keys (path- bad-path good-path))))
         (count (keys bad-path)))))
#+end_src

looks promising
#+begin_example
  asm-gp=> (path-diff-at "ultrix-deroff")
  9/13                 
  asm-gp=> (path-diff-at "ultrix-look")  
  7/12
  asm-gp=> (path-diff-at "ultrix-uniq")
  2/3
  asm-gp=> 
#+end_example

** DONE script for collecting stats from many "bests"
   - State "DONE"       from "TODO"       [2010-02-25 Thu 20:28]
   - State "TODO"       from ""           [2010-02-25 Thu 20:16]
   :PROPERTIES:
   :tangle:   scripts/bests.clj
   :ID:       60064795-62ef-4161-9d8c-0dc43d590b94
   :END:

#+begin_src clojure :shebang #! /usr/bin/env clj
  (load-file "/home/eschulte/research/genprog/asm/src/asm-gp.clj")(in-ns 'asm-gp)

  (def ops {:swap 0 :delete 0 :append 0 :crossover 0})
  (def opsize 0)
  (def total 0)
  (def trials 0)

  (defn ingest-ops [operations]
    (doseq [op operations]
      (if (list? op)
        (ingest-ops op)
        (def ops (assoc ops op (inc (op ops)))))))

  (while-let
   [line (read-line)]
   (when-let [best (read-obj line)]
     (def total (inc total))
     (def trials (+ trials (:trials best)))
     (def opsize (+ opsize (count (:operations best))))
     (ingest-ops (:operations best))))

  (println "total" total (/ total total))
  (println "trials" trials (/ trials total))
  (println "opsize" opsize (/ opsize total))
  (println "ops" ops)
#+end_src

** DONE write a script wrapper for shell script execution
   - State "DONE"       from "TODO"       [2010-02-25 Thu 20:16]
   - State "TODO"       from ""           [2010-02-06 Sat 12:35]

This should respond to most of the same commands as the existing
genprog =modify= command.

also, we should write out the STDOUT to debug files as done by
=modify=

** DONE begin tracking more meta-information on individuals
   - State "DONE"       from "TODO"       [2010-01-29 Fri 12:01]
   - State "TODO"       from ""           [2010-01-29 Fri 11:05]

interesting things to collect
- GP operations
- fitness
- number of fitness operations

So an individual will look like...
- :representation :: the representation, the actual lines of code
- :fitness :: the numerical fitness of the individual, or nil if it is
     yet to be computed
- :trials :: number of the total number of fitness trials (global)
     that have been performed when the individual last had it's
     fitness determined
- :operations :: a list of the gp operations applied thus far (or nil
     for the baseline individual)
- :compile :: true or false

** DONE add a timeout to the commands used to run tests
   - State "DONE"       from "TODO"       [2010-01-29 Fri 10:43]
   - State "TODO"       from ""           [2010-01-29 Fri 10:01]
   :PROPERTIES:
   :ID:       278c82ef-13d5-4f83-b0b6-2c5f59fac590
   :END:
Sometimes these commands will hang forever holding up the entire
machinery of GP.

See this [[http://stackoverflow.com/questions/808276/how-to-add-a-timeout-value-when-using-javas-runtime-exec][stackoverflow-post]] for the java solution, and see the current
clojure code [[http://github.com/richhickey/clojure-contrib/blob/master/src/main/clojure/clojure/contrib/shell_out.cljhttp://github.com/richhickey/clojure-contrib/blob/master/src/main/clojure/clojure/contrib/shell_out.clj][here:shell_out.clj]].

Ah, there's a much better solution
#+begin_src clojure
  (defmacro time-limited [ms & body]
    `(let [f# (future ~@body)]
       (.get f# ~ms java.util.concurrent.TimeUnit/MILLISECONDS)))
#+end_src
from [[http://stackoverflow.com/questions/1683680/clojure-with-timeout-macro][stackoverflow:clojure-with-timeout-macro]]

** DONE problems with java bytecode manipulation
   - State "DONE"       from "TODO"       [2010-01-22 Fri 21:47]
   - State "TODO"       from ""           [2010-01-22 Fri 20:57]
   :PROPERTIES:
   :ID:       efba0fde-ec45-40c3-baaa-c07737f03b9b
   :END:

Sadly the only reasonable fix here is to move from list
representations to InstructionList representations.

so when I'm inserting new byte-codes into the lists of instructions,
the instruction targets aren't being updated -- probably because I'm
not using the built-in insertion function.

Is there a way to automatically update the targets of instructions
when an instruction changes it's position using .setPositions?

subscribed to bcel-user-subscribe@jakarta.apache.org

*fixed*
#+begin_src clojure
  (fitness-asm (let [lst (.copy baseline)
                     handles (seq (.getInstructionHandles lst))]
                 (.append lst
                          (nth handles 14)
                          (.getInstruction (last handles)))
                 lst))
#+end_src

** TODO java good/bad paths
   - State "TODO"       from ""           [2010-01-22 Fri 16:08]

** DONE repair something that can't be repaired currently
   - State "TODO"       from ""           [2010-01-21 Thu 21:21]

something like transposed arguments, wrong type declaration, etc...

this has been done on sendmail

** DONE reproduce repairs for the ICSE experiments
   - State "TODO"       from ""           [2010-01-21 Thu 21:19]

should try all of these -- see [[file:~/research/genprog/genprog.org]]

** CANCELED compare effect of statistical vs. full paths
   - State "CANCELED"   from "TODO"       [2010-05-28 Fri 17:46] \\
     this todo is now located in the genprog.org file
   - State "TODO"       from ""           [2010-01-21 Thu 21:06]

#+begin_quote
  oprofile is a nice idea. You've sidesteped one implementation
  bottleneck. However, oprofile is statistical and not
  deterministic. One experiment you may want to run (or one threat to
  validity you may want to mention in a paper) is the effect of noisy
  fault localization on repair success and effort.
#+end_quote

** DONE manipulating java bytecode
   - State "DONE"       from "STARTED"    [2010-01-22 Fri 09:10]
   - State "STARTED"    from "TODO"       [2010-01-22 Fri 08:19]
   - State "TODO"       from ""           [2010-01-20 Wed 09:20]
   :PROPERTIES:
   :blog:     t
   :type:     task
   :END:

Changing our GP tools to work with Java [[http://en.wikipedia.org/wiki/Java_bytecode][byte codes]].

We are now able to read, write, and compile java .class files using
the over-defined asm methods below.

*** Over-defining some ASM functions
    :PROPERTIES:
    :ID:       1eb5203e-c998-4a73-8d89-39cc8ffb44c1
    :END:
*This code now lives in with the rest of the source code*

so we just need to over-define our read-asm, write-asm, and
compile-asm functions to work with java.
#+begin_src clojure
  (in-ns 'asm-gp)
  (import '(org.apache.bcel.classfile ClassParser)
          '(org.apache.bcel.generic ClassGen MethodGen InstructionList))
#+end_src

introducing a new global variable to hold information needed to write
new byte-code strings to a .class file.
#+begin_src clojure
  (def base-class nil)
#+end_src

new functions for reading and writing assembly files
#+begin_src clojure
  (defn read-asm
    "Read in a .class file to a list of Byte-code instructions.  For now
    we'll just be working with the main function." [path]
    (let [class (new ClassGen (.parse (new ClassParser path)))
          method (new MethodGen
                      (second (.getMethods class))
                      (.getClassName class)
                      (.getConstantPool class))]
      (.getInstructionList method)))

  (defn write-asm
    "Write a list of Byte-code instructions to a file." [f lst]
    (if (not base-class)
      (message "base class is uninitialized!"))
    (let [cls (new ClassGen base-class)
          mth (new MethodGen (second (.getMethods cls))
                   (.getClassName cls)
                   (.getConstantPool cls))]
      (.setPositions lst false)
      (.setInstructionList mth lst)
      (.setMaxStack mth)
      (.setMaxLocals mth)
      (.removeLineNumbers mth)
      (.replaceMethod cls
                      (second (.getMethods cls))
                      (.getMethod mth))
      (.dump (.getJavaClass cls) f)))
#+end_src

over-defining all GP operations for InstructionLists
#+begin_src clojure
  (defn append-asm
    "Append an instruction somewhere in this InstructionList.  Not
    Weighted."
    ([lst _] (append-asm lst))
    ([lst]
       (let [lst (.copy lst)
             handles (seq (.getInstructionHandles lst))]
         (try
          (.append lst
                   (pick handles)
                   (.getInstruction (pick handles)))
          (catch Exception e nil))
         lst)))

  (defn delete-asm
    "Remove an instruction from list InstructionList.  Not Weighted"
    ([lst _] (delete-asm lst))
    ([lst]
       (let [lst (.copy lst)
             handles (seq (.getInstructionHandles lst))]
         (try
          (.delete lst (pick handles))
          (catch Exception e nil))
         lst)))

  (defn swap-asm
    "Swap two instructions in this InstructionList.  Not Weighted."
    ([lst _] (swap-asm lst))
    ([lst]
       (let [lst (.copy lst)
             handles (seq (.getInstructionHandles lst))
             place (rand-int (dec (count handles)))
             target (pick handles)]
         (try
          (.move lst (nth handles place) target)
          (.move lst target (nth handles (inc place)))
          (catch Exception e nil))
         lst)))
#+end_src

new fitness and compilation functions
#+begin_src clojure
  (defn compile-asm
    "Compile the asm and return a path to the resulting binary."  [asm]
    (let [asm-dir (.getPath (File/createTempFile "variant" ""))]
      (s/sh "rm" asm-dir) (s/sh "mkdir" asm-dir)
      (try
       (write-asm (str asm-dir "/" (.getClassName base-class) ".class") asm)
       asm-dir
       (catch Exception e nil))))
#+end_src

Had some serious trouble working with a mutable list of byte-codes,
which need to be altered by an imperative library, in a functional
way.  Turns out the problem here was just forgetting that map was
lazily evaluated -- thanks to =jcromartie= and =lpetit= from
=#clojure= for helping with this solution.
#+begin_src clojure :tangle no
  (defn write-asm [f asm]
    (let [lst (InstructionList.)
          cls (new ClassGen base-class)
          mth (new MethodGen (second (.getMethods cls))
                   (.getClassName cls)
                   (.getConstantPool cls))]
      (doseq [x asm] (.append lst x))
      (.setPositions lst false)
      (.replaceMethod cls
                      (second (.getMethods cls))
                      (.getMethod mth))
      (.dump (.getJavaClass cls) f)))

  (defn list-expand [asm]
    (with-local-vars [lst (new InstructionList)
                      cls (new ClassGen base-class)
                      mth (new MethodGen (second (.getMethods cls))
                               (.getClassName cls)
                               (.getConstantPool cls))]
      (dorun (map #(.append (var-get lst) %) asm))
      (.setPositions (var-get lst) false)
      (var-get lst)))





  (map #(.append lst %) baseline)
#+end_src

*** Java bytecode manipulation libraries
http://java-source.net/open-source/bytecode-libraries

After trying a couple tools it looks like bcel is the way to go.

**** bcel
     :PROPERTIES:
     :ID:       864c75e4-37e3-496b-98b5-68a4ac5c87a1
     :END:
[[http://jakarta.apache.org/bcel/][bcel]] is another possibility, the following is taken largely from the
bcel tutorial at [[http://www.moparisthebest.com/smf/index.php?topic=160681.0][moparisthebest]].

installed from svn
: svn co http://svn.apache.org/repos/asf/jakarta/bcel/trunk/
then added to my =project.clj= file

#+begin_src clojure
  (import org.apache.bcel.classfile.ClassParser)
  (import 'org.apache.bcel.generic ClassGen MethodGen)
  ;; load up our .class file
  (def gcd (new ClassGen (.parse (new ClassParser "gcd_java/gcd.class"))))
  ;; print out the names of all methods
  (map #(.getName %) (.getMethods gcd))
  ;; to change the bytes in a method we need a MethodGen for that method.
  ;; get a methodGen for each method
  (map #(new MethodGen % (.getClassName gcd) (.getConstantPool gcd)) (.getMethods gcd))
  ;; get the methodGen for the main method
  (def main (second (map #(new MethodGen % (.getClassName gcd) (.getConstantPool gcd)) (.getMethods gcd))))
  ;; get the instruction list for the main method
  (def instrs (.getInstructionList main))
  ;; get the handles for this list
  (def handles (map identity (.getInstructionHandles instrs)))
  ;; remove an instruction
  (.delete instrs (nth handles 8))
  ;; set these instructions back into main
  (.setInstructionList main instrs)
  ;; cleanup
  (.setPositions instrs)
  (.setMaxStack main)
  (.setMaxLocals main)
  (.removeLineNumbers main)
  ;; replace old main with new main
  (.replaceMethod gcd (second (.getMethods gcd)) (.getMethod main))
  ;; write out the .class file
  (.dump (.getJavaClass gcd) "gcd_java/gcd2.class")
#+end_src

lets see if we get errors with increasing expansions of the following steps
- ClassGen -- works
- Method -- works
- MethodGen -- works
- InstructionList -- works
- Array of Instructions -- works

code for full circle to a clojure list and back
#+begin_src clojure
  (def gcd (new ClassGen (.parse (new ClassParser "gcd_java/gcd.class"))))
  (def main (second (.getMethods gcd)))
  (def main_gen (new MethodGen main (.getClassName gcd) (.getConstantPool gcd)))
  (def instrs (.getInstructionList main_gen))
  (def new_is (new InstructionList))
  (def inst_lst (map #(.getInstruction %) (.getInstructionHandles instrs)))
  (def new_inst_lst (concat (take 15 inst_lst) (list (last inst_lst)) (drop 15 inst_lst)))
  (map #(.append new_is %) new_inst_lst)
  (.setPositions new_is false)
  (.setInstructionList main_gen instrs)
  (.replaceMethod gcd (second (.getMethods gcd)) (.getMethod main_gen))
  (.dump (.getJavaClass gcd) "gcd_java/gcd.class")
#+end_src

**** java tools
Java provides a number of tools for the generation and inspection of
[[http://en.wikipedia.org/wiki/Java_bytecode][byte codes]].
- =javac= is the compiler which can be used to turn a java file into
  compiled binary byte code
  : javac gcd.java
  results in the creation of a binary =java.class= file containing the
  byte-codes
- =javap= can be used to disassemble the resulting class file
  : javap -c gcd
  outputs the following list of the java bytecode instructions
  #+begin_example
    javap -c gcd
    Compiled from "gcd.java"
    class gcd extends java.lang.Object{
    gcd();
      Code:
       0:   aload_0
       1:   invokespecial   #1; //Method java/lang/Object."<init>":()V
       4:   return

    public static void main(java.lang.String[]);
      Code:
       0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;
       3:   ldc     #3; //String Hello World!
       5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8:   return

    }
  #+end_example

now how to get from this pretty printed byte-code output to a loadable
=.class= file...

**** serp
[[http://serp.sourceforge.net/][serp]]

**** gnu.bytecode
     :PROPERTIES:
     :ID:       9fb0fc93-486e-49d3-a686-81d920811a4b
     :END:
Looks like the [[http://www.gnu.org/software/kawa/api/gnu/bytecode/package-summary.html][gnu.bytecode]] library should be helpful here.

I think I've wrestled this library (contained in [[http://www.gnu.org/software/kawa/][kawa]]) into my
projects dependencies via [[http://github.com/technomancy/leiningen][lein]].

finally able to read in a =.class= file with
#+begin_src clojure
  (new gnu.bytecode.ClassFileInput (java.io.FileInputStream. "gcd_java/gcd.class"))
#+end_src
** CANCELED find java bugs in open-source software
   - State "CANCELED"   from "TODO"       [2010-05-28 Fri 17:47] \\
     this todo is now tracked in genprog.org
   - State "TODO"       from ""           [2010-01-20 Wed 10:31]

from http://www.linuxjournal.com/article/4860
#+begin_quote
  Examples of free projects using Java include Jakarta from the Apache
  Foundation (jakarta.apache.org), various XML tools from W3C
  (www.w3.org) and Freenet (freenet.sourceforge.net). See also the
  FSF's Java page (www.gnu.org/software/java).
#+end_quote

** TODO generate diffs of variants
   - State "TODO"       from ""           [2010-01-19 Tue 10:45]
they are *much* smaller than the entire individual and would greatly
decrease storage space for things like the gp-operation results

** DONE general path generation
   - State "DONE"       from "STARTED"    [2010-01-17 Sun 11:12]
   - State "STARTED"    from "TODO"       [2010-01-16 Sat 17:12]
   - State "TODO"       from ""           [2010-01-16 Sat 16:11]
   :PROPERTIES:
   :CUSTOM_ID: general-path-generation
   :blog:     t
   :type:     task
   :END:
The following technique can be used to sample the bad path from "any"
program running on a linux OS -- for which you have the assembly code.
It uses [[http://oprofile.sourceforge.net/news/][oprofile]] and is able to associate the memory addresses
reported by oprofile with lines of assembly files.

alright, so this is working with oprofile.  First oprofile must be
turned on with something like the following...
: opcontrol --start

then either the good or bad test-case should be run some number of
times

then the annotated assembly can be read out with a command like the
following.
: opannotate --assembly ../../null

the output of that command looks something like
#+begin_example
     1  0.3257 : 804f318:       cmpl   $0x1,-0x10(%ebp)
     3  0.9772 : 804f31c:       je     804f323 <sgets+0x115>
               : 804f31e:       negl   -0xc(%ebp)
               : 804f321:       jmp    804f347 <sgets+0x139>
               : 804f323:       addl   $0x1,-0xc(%ebp)
     1  0.3257 : 804f327:       mov    0x8(%ebp),%eax
               : 804f32a:       movzbl (%eax),%eax
               : 804f32d:       cmp    $0xa,%al
     1  0.3257 : 804f32f:       jne    804f337 <sgets+0x129>
               : 804f331:       addl   $0x1,0x8(%ebp)
#+end_example

and should be usable for assigning good/bad paths to the assembly file

finally shut down with
: opcontrol --shutdown

and find out how to clear out the resident information before
profiling the next path

putting this all together to get some paths
1) get the mapping from memory addresses to lines in the assembly file
   : clj ../mem-mapping.clj httpd_comb.s null
2) stop the daemon
   : sudo opcontrol --shutdown
3) clear out old information
   : sudo opcontrol --reset
4) start up the daemon
   : sudo opcontrol --start
5) run the good test 10 times
   #+begin_src sh
     for i in `seq 10`; do
         j=`expr $i - 1`
         ./test-good.sh ./null output 401$j
     done
   #+end_src
6) dump the annotations to lines in the assembly file and save the
   results in good.path
   : opannotate --assembly null | clj ../opannotate-to-path.clj > good.path

*** better =mem-mapping= to lines of asm
    :PROPERTIES:
    :tangle:   scripts/mem-mapping.clj
    :CUSTOM_ID: mem-mapping
    :END:

this script will disassemble every function in the assembly file, and
will use GDB to map memory locations to lines in the original
assembly.  To run it needs the path to the assembly file, and to the
compiled binary.  The mapping is written to =mapping.clj=.
: clj mem-mapping.clj httpd_comb.s nullhttpd
#+source: mem-to-asm
#+begin_src clojure :shebang #! /usr/bin/env clj
  (load-file "/home/eschulte/research/genprog/asm/src/asm-gp.clj")
  (in-ns 'asm-gp)
  
  (def asm-file (:representation (read-asm (second *command-line-args*))))
  (message "asm file: %s %d lines" (second *command-line-args*) (count asm-file))
  (def bin-file (nth *command-line-args* 2))
  (message "bin-file: %s" bin-file)
  (def mapping {})
  
  (defn function-lines [asm]
    (filter identity
            (map #(and (string? %)
                       (if-let [match (re-matches #"([^\.].+):" %)]
                         (second match)))
                 (map :line asm))))
  (defn gdb-disassemble
    "Takes the path to a binary, and the name of the symbol to be
    disassembled."  [path function]
    (s/sh "gdb" "--batch"
          (format "--eval-command=disassemble %s" function) path))
  
  (dorun
   (map ;; for every function defined in the file
    (fn [func]
      (let [lines (seq (.split (gdb-disassemble bin-file func) "\n"))]
        ;; step to beginning of function
        (def pointer 0)
        (while (not (= (format "%s:" func) (:line (nth asm-file pointer))))
               (def pointer (inc pointer)))
        (def pointer (inc pointer))
        (message "\t%s:%d %d lines" func (dec pointer) (count lines))
        (dorun
         (map ;; build up the mapping of memory address to LOC
          #(when-let [matches (re-matches
                               #"[\s]*([\w]+)[\s]*<[\w+]*\+([\d]+)>:.*" %)]
             ;; step past .L lines which aren't noticed by gdb
             (while (and (string? (:line (nth asm-file pointer nil)))
                         (re-matches #"\.L.+" (:line (nth asm-file pointer nil))))
                    (def pointer (inc pointer)))
             ;; associate this memory address with this line in the asm-file
             (def mapping (assoc mapping (nth matches 1) pointer))
             (def pointer (inc pointer)))
          lines))))
    (function-lines asm-file)))
  
  (write-obj "mapping.clj" mapping)
#+end_src

*** =opannotate-to-path=
    :PROPERTIES:
    :CUSTOM_ID: opannotate-to-path
    :tangle:   scripts/opannotate-to-path.clj
    :END:
Map output from opannotate to a path in the related asm file.  This
requires the =mapping.clj= written out by [[mem-mapping]], and it accepts
the output of =opannotate= through a pipe.

#+begin_src clojure :shebang #! /usr/bin/env clj
  (load-file "/home/eschulte/research/genprog/asm/src/asm-gp.clj")(in-ns 'asm-gp)

  (def mapping (read-obj "mapping.clj"))

  (while-let
   [line (read-line)]
   ;;     10 27.7778 : 804ba03:
   (when-let [match (re-matches #"[\s]+([\d]+)[\s]+([\.\d]+)[\s]+:[\s]+([\w]+):.*" line)]
     (dorun
      (map
       (fn [_] (if-let [line (or (mapping (format "0x0000000000%s" (nth match 3)))
                                 (mapping (format "0x0%s" (nth match 3))))]
                 (println line)))
       (range (Integer/parseInt (nth match 1)))))))
#+end_src

*** using gdb to attach to a running process
with something like
: gdb program-path program-id

then run a series of =step= commands dumping the output to a file

*** oprofile
try using [[http://oprofile.sourceforge.net/]]

*** IRC help from #gdb
#+begin_quote
15:46 <_schulte_> I'd think that there would be a general utility
                  for sampling the program counter of a running
                  program, but I've not been able to find anything
15:47 <jankratochvil> _schulte_: Sampling for which purpose? For
                      profiling purposes it is done by gcc -pg &
                      gprof, currently superseded by oprofile.
15:48 <jankratochvil> For GDB-script programming see: $ info
                      '(gdb)Command Files'
15:48 <_schulte_> jankratochvil: I need to find out which lines of
                  an assembly file are being executed, and with
                  what frequency
15:49 <jankratochvil> For python programming: $ info '(gdb)Python'
15:49 <_schulte_> if I can just get the contents of the program
                  counter then I can use that to get the related
                  lines in the .s file
15:49 <jankratochvil> _schulte_: So maybe gcov but I do not have
                      experience with it myself.
15:50 <_schulte_> jankratochvil: thanks, so far everything I've
                  looked into works over C files, and need to be
                  able to instrument the generated assembly --
                  which isn't possible in my case
15:51 <jankratochvil> These tools generally just insert some call
                      into prologue and epilogue so you can insert
                      it there yourself to catch the point when
                      execution enters your function.  See `gcc -S'
                      output for these called instrumentation
                      functions.
15:53 <_schulte_> jankratochvil: alright, that sounds promising,
                  I'll give it a try. thanks
15:54 <jankratochvil> np, perusing these instrumentation gcc calls
                      can be useful. :-)
16:01 <_schulte_> it looks like I can also attach to a running
                  program, and then use step/stepi to inspect the
                  state.  maybe wrapping that in a shell script
                  which I could repeatedly call would be
                  sufficient...
16:09 <jankratochvil> _schulte_: If you do not need to catch _each_
                      entry and you want just some statistical
                      sample then you want oprofile.  Or you can
                      implement it yourself by fast setitimer()
                      handler saving the - probably caller's caller
                      - PC each time.
16:10 <jankratochvil> oprofile - contrary to gprof - does not need
                      any instrumentation and DWARF debug info is
                      enough for it.
16:10 <_schulte_> jankratochvil: that sounds perfect, thanks!
#+end_quote

** DONE better caching
   - State "DONE"       from "TODO"       [2010-01-15 Fri 15:36]
   - State "TODO"       from ""           [2010-01-15 Fri 15:25]
   :PROPERTIES:
   :tangle:   no
   :ID:       c53b23d2-831f-4ee5-a04c-c25ef19d80d2
   :END:

Better consistent hashing
- hash fitness by sha1 of individual rather than full asm

  this can be accomplished using Java's =.hashCode= method directly on
  an individual
  #+begin_src clojure
    (.hashCode basline)
  #+end_src

- persist fitness hash on disk between runs, can be accomplished by
  explicitly loading and saving the fitness-cache from a specified
  location, lets say... "~/research/code/data/fitness-cache.clj"

** DONE expand some big programs
see how the asm scales with the size of the C program

** DONE more literature review
   - State "TODO"       from ""           [2010-01-13 Wed 09:23]
- [[file:data/ksplice.pdf][ksplice.pdf]] look in the references of this paper (skim notes)

** DONE differentiate between bad and worse failures
   - State "DONE"       from "TODO"       [2010-01-11 Mon 00:24]
   - State "TODO"       from ""           [2010-01-08 Fri 16:03]
   :PROPERTIES:
   :blog:     t
   :type:     task
   :CUSTOM_ID: diff-between-bad-and-worse
   :END:
So this is inspired fairly directly by VU's challenge script, which
takes advantage of the fact that our current system can't
differentiate between failing a test by returning the wrong result --
(e.g. printing 56 instead of 55) and failing a test for more serious
reasons like throwing a segfault or entering an infinite loop.

Here we'll try assigning test results in a less dramatic fashion,
basically we'll give 1 point for passing the test, 0 points for a
non-0 exit (either segfault or infinite loop), and a new gradation of
0.5 points just for exiting cleanly.  While it would be possibly to do
much more like assigning fitness based on running time this seems just
fine for now.

*** implementation
    :PROPERTIES:
    :ID:       24242c3c-77fc-4e6f-a67c-64d9c3d2e56c
    :END:
The =time= command looks like it will be sufficient.

changing test-bad.sh from
#+begin_src sh
  #!/bin/sh
  ulimit -t 1
  $1 0 55 2> /dev/null | diff output.0.55 - &> /dev/null && (echo "0 55")
  exit 0
#+end_src
to
#+begin_src sh
  #!/bin/sh
  ulimit -t 1
  time $1 0 55 2> /dev/null | diff output.0.55 - &> /dev/null && (echo "0 55")
  exit 0
#+end_src

will print the time taken to run the command to STDERR, so for example
the output of a working gcd will be
#+begin_example
real    0m0.006s
user    0m0.004s
sys     0m0.004s
#+end_example
and the output of a broken infinite-loop gcd will be
#+begin_src
real    0m0.998s
user    0m1.004s
sys     0m0.000s
#+end_src
so it should be fairly easy to catch this STDERR output in clojure and
use it to adjust the score of the resulting scripts.

#+begin_src clojure :session asm-gp
  (let [out (s/sh test bin :return-map true)
        user (re-matches #"user\t(\d+)m([\d\.]+)s"
                         (nth (.split (:err out) "\n") 2))
        user-time (+ (* 60 (Double/parseDouble (second user)))
                     (Double/parseDouble (nth user 2)))
        clean-exit (and (< user-time 0.9) (= 0 (:exit out)))
        lines (count (remove #(= "" %)
                       (seq (.split (out :out) "\n"))))]
    (if (> lines 0) lines (if clean-exit 0.5 0)))
#+end_src

** DONE find a good set of training c/asm source code
   - State "DONE"       from "DONE"       [2010-01-03 Sun 12:00]
   :PROPERTIES:
   :blog: t
   :type:     task
   :ID:       a2c9d20d-1826-441b-b595-6b4ba8b03e63
   :END:
I collected 34 short C programs from [[http://rosettacode.org/wiki/Category:C][rosettacode]].  These programs were
selected for their simple subject matter (mainly mathematical or array
sorting) and their lack of any dependencies aside from standard
libraries.  These programs are contained in [[file:data/c-samples.2010-01-03.34-working.tar.bz2][c-samples.tar.bz2]].

These 22 programs can be compiled to assembly files using the
following
#+begin_src clojure
  (def dir (.getPath (file-str "~/Desktop/c-samples")))
  (def source-basenames
       (filter identity (map #(second (re-matches #"(.*)\.c" %))
                             (.list (new File dir)))))
  ;; compile
  (map (fn [path] (s/sh "gcc" "-o"
                        path
                        (format "%s.c" path)
                        :dir (f/file-str dir))) source-basenames)

  (comment ;; to train against these sources
    (train (map read-asm sources) 4)
    )
#+end_src

** DONE find a bad path -- profiling assembly files
   - State "DONE"       from "DONE"       [2010-01-06 Wed 12:00]
   :PROPERTIES:
   :blog:     t
   :type:     task
   :END:
genprog makes good use of "good paths" and "bad paths" to see which
portions of a source-code files are run during both the good and bad
tests.  This information is used to focus on the mutation of
source-code files towards those lines involved in failing the bad
test.

This work will benefit from the ability to find which lines of an
assembly file are used during execution of each test.  Luckily gdb
makes this task relatively simple -- as long as the lines in question
are contained inside of a named function (for example =main=).

see
- [[gdb-script]] for a script which runs a file and returns the value of
  the program counter after each step of assembly execution
- [[mem-to-asm]] for a clojure script which takes the path to the asm file
  and can accept the output of [[gdb-script]] through a pipe and spits out
  the loc in the assembly file related to the program counter sampled
  by gdb

*** GDB-script
    :PROPERTIES:
    :CUSTOM_ID: gdb-script
    :END:
Writing a simple gdb script [[file:data/asm-profile.gdb][asm-profile.gdb]] which can be run with
: gdb gcd -batch -x data/asm-profile.gdb |grep -e "in main ()" > output

it looks like
#+begin_example
  disassemble main
  break main
  run 0 55
  stepi
  stepi
  stepi
  ...
#+end_example

piped through this [[mem-to-asm][little clojure script]] to extract the addresses
: gdb -batch gcd -x data/asm-profile.gdb |clj mem-to-asm.clj

associates memory addresses with the assembly codes following =main=
in the assembly source-code file.

*** mem-to-asm
     :PROPERTIES:
     :tangle:   scripts/mem-to-asm.clj
     :CUSTOM_ID: mem-to-asm
     :END:

When called on the command line using a line such as
: gdb -batch gcd -x data/asm-profile.gdb |clj mem-to-asm.clj gcd.s
this script will
1) read in the asm file (in this case =gcd.s=)
2) read the output from gdb disassemble and use it to associate memory
   addresses with loc in the asm file
3) read the values of the program-counter output by gdb and translate
   them on the fly to loc in the assembly file which are printed to
   STDOUT

#+begin_src clojure :shebang #! /usr/bin/env clojure
  (load-file "/home/eschulte/research/genprog/asm/src/asm-gp.clj")(in-ns 'asm-gp)

  (def asm-file (read-asm (second *command-line-args*)))

  (def pointer 0)

  (while (not (= "main:" (:line (nth asm-file pointer))))
         (def pointer (inc pointer)))
  (def pointer (inc pointer))

  (def mapping {})

  (while-let
   [line (read-line)]
   ;; build up the mapping
   (when-let [matches (re-matches #"([\w]+) <main\+([\d]+)>:.*" line)]
     ;; step past .L lines which aren't noticed by gdb
     (while (and (string? (nth asm-file pointer))
                 (re-matches #"\.L.+" (nth asm-file pointer)))
            (def pointer (inc pointer)))
     ;; associate this memory address with this line in the asm-file
     (def mapping (assoc mapping (nth matches 1) pointer))
     (def pointer (inc pointer)))
   ;; apply the mapping
   (when-let [hex (second (re-matches #"([\w]+) in main \(\)" line))]
     (println (mapping hex))))
#+end_src

*** reference
sources
- [[http://en.wikipedia.org/wiki/X86_assembly_language#Using_the_instruction_pointer_register][using-the-instruction-pointer]]
- [[wiki:Instruction_pointer]]
- the GDB api
- look on #gdb irc channel and ask for help
- here's a [[http://rosettacode.org/wiki/Print_a_Stack_Trace#C][stack trace in C]]

some useful gdb instructions include
- =display/i $pc= which will print the next line of assembly after
  each step
- =stepi= which steps at the instruction level
- =info registers= which prints the contents of the registers
- =disassemble main= which prints the assembly for a function -- in
  this case =main=

there is a good gdb tutorial at [[http://www.linuxjournal.com/article/7876][linuxjournal:emacs-and-gdb]], or with a
focus on assembly see [[http://www.unknownroad.com/rtfm/gdbtut/gdbadvanced.html][gdbadvanced]]

I should really grow up and write a C program which uses [[http://www.cs.utah.edu/dept/old/texinfo/libgdb/libgdb.html][libgdb]]

*** close look at output
    :PROPERTIES:
    :ID:       44ba44c6-bfa0-4af6-ba84-e3abd7b590e9
    :END:
thought maybe there was a way to find a constant mapping between the
offset number in the gdb output, and the command, but there are times
when the same command pattern takes up different amounts of offset

This table tries to map commands to the amount of offset they absorb
in memory (reported by gdb disassemble), as far as I can tell there is
not an easy consistent mapping.
| push        | 1 |
| mov         | 2 |
| and         | 3 |
| sub         | 3 |
| mov 0xc()   | 3 |
| add         | 3 |
| mov , ()    | 2 |
| call        | 5 |
| mov , 0xc() | 4 |
| fild 0xc    | 4 |
| fstp 0xc    | 4 |
| mov ()      | 2 |
| mov , ()    | 3 |

#+results: gdb-disassemble-output
|   0 | push    |
|   1 | mov     |
|   3 | and     |
|   6 | sub     |
|   9 | mov     |
|  12 | add     |
|  15 | mov     |
|  17 | mov     |
|  20 | call    |
|  25 | mov     |
|  29 | fildl   |
|  33 | fstpl   |
|  37 | mov     |
|  40 | add     |
|  43 | mov     |
|  45 | mov     |
|  48 | call    |
|  53 | mov     |
|  57 | fildl   |
|  61 | fstpl   |
|  65 | fldl    |
|  69 | fldz    |
|  71 | fxch    |
|  73 | fucompp |
|  75 | fnstsw  |
|  77 | sahf    |
|  78 | jne     |
|  80 | jp      |
|  82 | fldl    |
|  86 | fstpl   |
|  90 | movl    |
|  97 | call    |
| 102 | jmp     |
| 104 | fldl    |
| 108 | fldl    |
| 112 | fxch    |
| 114 | fucompp |
| 116 | fnstsw  |
| 118 | sahf    |
| 119 | seta    |
| 122 | test    |
| 124 | je      |
| 126 | fldl    |
| 130 | fsubl   |
| 134 | fstpl   |
| 138 | jmp     |
| 140 | fldl    |
| 144 | fsubl   |
| 148 | fstpl   |
| 152 | fldl    |
| 156 | fldz    |
| 158 | fxch    |
| 160 | fucompp |
| 162 | fnstsw  |
| 164 | sahf    |
| 165 | jne     |
| 167 | jp      |
| 169 | fldl    |
| 173 | fstpl   |
| 177 | movl    |
| 184 | call    |
| 189 | mov     |
| 194 | leave   |
| 195 | ret     |
|     |         |

#+begin_src clojure :session asm-gp :var gdb=gdb-disassemble-output
  (def gdb gdb)
#+end_src

** DONE effectively use good and bad paths
   - State "DONE"       from "DONE"       [2010-01-07 Thu 12:00]
   :PROPERTIES:
   :tangle:   no
   :session:  asm-gp
   :blog:     t
   :type:     task
   :ID:       9fbd6a4c-47c7-4532-8ed9-bff3ab5c9dcb
   :END:

1) first we need to generate the good and bad paths

   A different command for each reflecting different good and bad
   arguments to the gcd executable.
   #+begin_src sh
     gdb -batch gcd -x data/good-profile.gdb |clj mem-to-asm.clj gcd.s > good.path
   #+end_src
   and
   #+begin_src sh
     gdb -batch gcd -x data/bad-profile.gdb |clj mem-to-asm.clj gcd.s > bad.path
   #+end_src

2) then we can take the bad-path subtract the good-path, and that
   should provide a good indication of where the GP should focus.
   #+begin_src clojure
     (def bad-path
          (reduce
           (fn [a f] (let [val (get a f 0)]
                       (if (> val 1)
                         (assoc a f (dec val))
                         (dissoc a f))))
           (reduce (fn [a f] (assoc a f (inc (get a f 0)))) {}
                   (map #(Integer/parseInt %) (f/read-lines "data/bad.path")))
           (map #(Integer/parseInt %) (f/read-lines "data/good.path"))))
   #+end_src

3) Then we apply this path to our baseline individual.  See [[apply-path]]
   #+begin_src clojure
     (def baseline (apply-path (read-asm "gcd.s") :bad-weight bad-path))
   #+end_src

for the experiment run using this setup see [[weighted-gp]]

** DONE doctor bad paths
   - State "DONE"       from "DONE"       [2010-01-08 Fri 12:37]
   :PROPERTIES:
   :blog:     t
   :type:     task
   :ID:       26b8baf3-0a60-4ddf-ab66-0a3ef23b9578
   :END:
As it turns out a strict bad path on the assembly instruction level
can be too narrow.  For example on the gcd.s code the bad path limits
the GP operations to the lines following =.L6:= -- namely the code
implementing the infinite loop

#+begin_src asm
  .L8:
          fldl    64(%esp)
          fstpl   4(%esp)
          movl    $.LC1, (%esp)
          call    printf
          jmp     .L4
  .L6:
          fldl    72(%esp)
          fldl    64(%esp)
          fxch    %st(1)
          fucompp
          fnstsw  %ax
#+end_src

however the solution needed to fix gcd.s is to replace the line
immediately preceding =.L6= to return *before* entering the infinite
loop.

to resolve this issue I'm going to try two things
1) I'll apply the log of the bad-path program counters rather than the
   actual number -- which is often in the thousands make weighted
   selection of non-bad-path lines of code practically impossible
   #+begin_src clojure
     (apply hash-map
            (apply concat
                   (map #(list (first %)
                               (m/log (inc (second %)))) bad-path)))
   #+end_src

2) I'll smooth out the weight so that the weight of a line is
   influenced by the weights of it's neighbors, lets say something
   like
   | 6% | 24% | 38% | 24% | 6% |
   #+begin_src clojure
     (let [kernel {-3 0.006, -2 0.061, -1 0.242, 0 0.383, 1 0.242, 2 0.061, 3 0.006}]
       (reduce ;; for each weighted element of the bad-path
        (fn [accum el]
          (reduce ;; for each part of the kernel
           #(let [place (+ (first el) (first %2))]
              (assoc %1 place
                     (+ (get %1 place 0)
                        (* (second %2) (second el)))))
           accum kernel))
        {} bad-path))
   #+end_src

doctoring has the following effect on the weights of the bad path
#+source: bad-path
#+begin_src clojure :session asm-gp :exports none
  (map #(apply list %) bad-path)
#+end_src
#+begin_src gnuplot
  set xrange [0:79]
  plot data using 1:2 with boxes notitle
#+end_src

| before                 | after                           |
|------------------------+---------------------------------|
| [[file:data/bad-path.png]] | [[file:data/bad-path-doctored.png]] |

** DONE use a good path
   - State "DONE"       from "TODO"       [2010-01-08 Fri 13:30]
   - State "TODO"       from ""           [2010-01-08 Fri 12:38]
   :PROPERTIES:
   :blog:     t
   :type:     task
   :ID:       1654f067-3523-4f25-a3f2-c6e76d3eed5d
   :END:

Same idea as the bad path, only using a good path to aid in selection
of replacement code.

1) The following can be used to find the good path.
   #+begin_src clojure :session asm-gp
     (def good-path
          (reduce
           (fn [a f] (let [val (get a f 0)]
                       (if (> val 1)
                         (assoc a f (dec val))
                         (dissoc a f))))
           (reduce (fn [a f] (assoc a f (inc (get a f 0)))) {}
                   (map #(Integer/parseInt %) (f/read-lines "data/good.path")))
           (map #(Integer/parseInt %) (f/read-lines "data/bad.path"))))
   #+end_src

2) then to doctor the good path
   #+begin_src clojure
     (def good-path
          (reduce ;; log of the weights
           #(assoc %1 (first %2) (m/log (inc (second %2)))) {}
           ;; 1D Gaussian Smoothing of weights
           (let [kernel {-3 0.006, -2 0.061, -1 0.242, 0 0.383, 1 0.242, 2 0.061, 3 0.006}]
             (reduce ;; for each weighted element of the good-path
              (fn [accum el]
                (reduce ;; for each part of the Gaussian kernel
                 #(let [place (+ (first el) (first %2))]
                    (assoc %1 place
                           (+ (get %1 place 0)
                              (* (second %2) (second el)))))
                 accum kernel)) {}
                 good-path))))
   #+end_src

   resulting in the following change
   | before                  | after                            |
   |-------------------------+----------------------------------|
   | [[file:data/good-path.png]] | [[file:data/doctored-good-path.png]] |

3) Then to adjust our GP functions so that they take account of the
   good and bad weights... done

4) Then generate a baseline with both good and bad path info
   #+begin_src clojure
     (def baseline
          (apply-path
           (apply-path (read-asm "gcd.s")
                       :good-weight good-path)
           :bad-weight bad-path))
   #+end_src

After four quick runs the GP was able to find a solution in *all four
runs*, which is a drastic improvement over all previous attempts.  I
guess it remains to be seen how well this improvement transfers to
other programs but it is encouraging.

** CANCELED bias GP operations towards common command patterns
   - State "CANCELED"   from "STARTED"    [2010-05-28 Fri 17:48] \\
     this doesn't help, better to leave the instructions as atomic units
   - State "STARTED"    from "DONE"       [2010-01-01 Fri 12:00]
   :PROPERTIES:
   :exports:  code
   :CUSTOM_ID: r-source-cmd-model
   :blog:     t
   :type:     task
   :END:

1) first build a model of the command patterns in *.s files (see
   [[r-source-cmd-model]])
2) write a function which uses a model to run the products of GP
   operations through tournaments (see [[better-gp-op]]) which seems to
   work with lines like
   #+begin_src clojure
     (better-gp-op del-asm baseline full-model 9)
   #+end_src

For some reason this doesn't really seem to help.

*** code -- ASM command pattern profiles
Learning what patterns of commands are actually used in assembly files
which are generated from C source code.
**** generalize commands into groups
     :PROPERTIES:
     :ID:       aef3b821-aec8-4d29-b379-7b6bbb91a437
     :END:
#+begin_src clojure
  (defn generalize-cmd [cmd]
    "Map a command into a more general command class."
    (cond
     ;; jump targets
     (and (string? cmd) (re-matches #"^\.L(\d+):" cmd))
     ".L"
     (and (string? cmd) (re-matches #"^\.LC(\d+):" cmd))
     ".LC"
     (and (string? cmd) (re-matches #"^\.LFB(\d+):" cmd))
     ".LFB"
     (and (string? cmd) (re-matches #"^\.LFE(\d+):" cmd))
     ".LFE"
     ;; globals
     (and (string? cmd) (re-matches #"^\.globl.*" cmd))
     ".globl"
     (and (string? cmd) (re-matches #"^(.+):$" cmd))
     (second (re-matches #"^(.+):$" cmd))
     ;; regular asm commands w/o arguments
     (and (string? cmd) (re-matches #"^\t(.+)$" cmd))
     (second (re-matches #"^\t(\S+).*$" cmd))
     ;; regular asm commands w/arguments
     (coll? cmd) (first cmd)))
#+end_src

**** pull patterns out of a collection of commands
     :PROPERTIES:
     :ID:       ef3197cb-eba3-4906-b1c5-7cb0ca768c9b
     :END:
#+begin_src clojure
  (defn patterns
    "Return the patterns in coll of length size or less along with their
    frequencies." [coll size]
    (reduce
     (fn [model f] (assoc model f (inc (get model f 0))))
     {}
     ((fn [coll size accum]
       (if (> size 0)
         (recur
          coll
          (- size 1)
          (concat
           (apply map list
                  ((fn [coll size accum]
                     (if (> size 0)
                       (recur coll (- size 1) (cons (drop size coll) accum))
                       (cons coll accum))) coll (- size 1) '()))
           accum))
         accum)) coll size '())))
#+end_src

**** compile a model of these command groups and their frequencies
     :PROPERTIES:
     :ID:       1c5b3dba-4ad6-4639-b9bc-9cd1f1705acb
     :END:
#+begin_src clojure
  (defn train [asms window-size]
  (reduce
   (fn [model map] (merge-with + model map))
   {} (map #(patterns (map generalize-cmd %) window-size) asms)))
#+end_src

**** model-similarity
     :PROPERTIES:
     :ID:       9dcc6eb5-11d2-4bb7-879c-7496920905a8
     :END:
Compare two models of cmd patterns returning an integer which is
proportional to the "similarity" in command patterns between the
models.
#+begin_src clojure
  (defn model-similarity
    "Return the similarity between two models of cmd patterns." [a b]
    ;; ensure both are cast as hash-maps
    (reduce #(+ %1 (or (b (first %2)) 0)) 0 a))
#+end_src

now with the "times length squared" portion removed

**** better-gp-op
    :PROPERTIES:
    :CUSTOM_ID: better-gp-op
    :END:

Run the supplied GP operation =tournament-size= times and select the
tournament winner as the variant with the highest pattern similarity
rating.
#+begin_src clojure
  (defn better-gp-op
    "Run the supplied GP operation =tournament-size= times and select
  the tournament winner as the variant with the highest pattern
  similarity rating."
    [op asm model tournament-size]
    (let [options (map (fn [n] (op asm)) (range tournament-size))]
      (first (last
              (sort-by second
                       (map #(list % (model-similarity
                                      (train (list %) 4)
                                      model)) options))))))
#+end_src

*** source code for the R stat project
    :PROPERTIES:
    :ID:       235ab42d-f5b0-429f-8a45-dc36c1e5658b
    :END:

1) first compiled the .c files
   #+begin_src sh
     find src -type f -name "*.c" -exec gcc -S {} \;
   #+end_src
2) then copied the big ones to a boilerplate directory
   #+begin_src ruby
     data.each{|f| system "cp #{f[0]} ~/research/code/boilerplate/" }
   #+end_src
3) trained a model against these files
   #+begin_src clojure
     (def sources (filter #(re-matches #".*\.s" %) (.list (new File dir))))
     (def sources (map (fn [path] (.getPath (new File dir path))) sources))
     (def model (train (map read-asm sources) 4))
   #+end_src
4) filtered the model down to only those patterns which were more than
   1 command line and appeared more than 8 times
   #+begin_src clojure
     (def model (filter #(< 1 (count (first %))) model))
     (def model (filter #(< 8 (second %)) model))
   #+end_src
5) save this model to a file
   #+begin_src clojure
     (write-obj "data/model" model)
   #+end_src

*** random small math scripts
in =data/boilerplate.2010-01-01.tar.bz2=

so I've collected 5 simple math programs written in C in the
=boilerplate= directory totaling 114 lines of code (including
comments).
: for i in boilerplate/*.c {cat $i |wc}

|  12 |  33 | 227 |
|  14 |  39 | 263 |
|  12 |  40 | 264 |
|  53 | 172 | 978 |
|  23 |  59 | 321 |
|-----+-----+-----|
| 114 |     |     |
#+TBLFM: $1=vsum(@1..@-1)

: for i in boilerplate/*.s {cat $i |wc}
|  46 | 117 |  784 |
|  51 | 130 |  847 |
|  51 | 130 |  847 |
|  68 | 170 | 1182 |
|  81 | 167 | 1110 |
|-----+-----+------|
| 297 |     |      |
#+TBLFM: $1=vsum(@1..@-1)

or 297 lines of assembly.

I'll now take these and find common patterns of commands in their
assembly code with [[usage-profiling]].

** DONE investigate out-of-memory error
see [[simple-gp-pinyon-sect-swp-crs]]

probably not too much to be done for it aside form allowing the heap
to take up more space...

: java -Xms<initial heap size> -Xmx<maximum heap size>

default is

: java -Xms32m -Xmx128m

** CANCELED new genetic operators "mutation" and "crossover"
   - State "CANCELED"   from "HOLD"       [2010-05-28 Fri 17:49] \\
     don't really need this
   - State "HOLD"       from "HOLD"       [2010-01-15 Fri 10:37]

These have been pulled out in order for a clean comparison with
genprog.  At some point in the future they may be re-evaluated and
replaced.

*** crossover
    :PROPERTIES:
    :ID:       19ea94fe-6685-40da-b528-9da8ea7e141f
    :END:
#+begin_src clojure
  (defn crossover
    "Combine two asm using double-point crossover.  This can be forced
  to a single line change by adding a third argument."
    ([mother father] (crossover mother father nil))
    ([mother father single]
       (let [m-start (weighted-place mother)
             m-length (if single 1
                          (weighted-place (drop m-start mother)))
             f-start (weighted-place father)
             f-length (if single 1
                          (place (drop f-start father)))]
         (concat (take m-start mother)
                 (take f-length (drop f-start father))
                 (drop (+ m-start m-length) mother)))))
#+end_src

*** mutation
Currently we swap the "argument" portion of a command with another
"argument" from the same command in the assembly file.  It might be
nice to come up with a good way to "change" rather than "swap" the
value of this argument -- possibly even keep a running list of all of
the possible valid values.

**** by command
    :PROPERTIES:
    :CUSTOM_ID: by-command
    :END:
returns a hash of assembly "commands" and their "arguments"
#+begin_src clojure
  (defn by-command
    "Return the commands in an assembly file along with a list of their
  possible predicates."
    [asm]
    ((fn [lines cmds]
       (if (> (count lines) 0)
         (let [lines (remove string? lines)
               line (first lines)
               others (rest lines)
               more-cmds (assoc cmds (first line)
                                (cons (second line) (cmds (first line))))]
           (recur others more-cmds))
         cmds)) (map :line asm) {}))
#+end_src
**** mutate
    :PROPERTIES:
    :CUSTOM_ID: mutate
    :END:
mutate a *single* command

#+begin_src clojure
  (defn mut-asm
    ([asm] (mut-asm asm nil))
    ([asm throw-away]
       (let [mut-point (weighted-place asm)
             mut-line (:line (nth asm mut-point))
             cmds (by-command asm)
             lines (filter string? (map :line asm))]
         (concat
          (take mut-point asm)
          (list (if (string? mut-line)
                  (pick lines)
                  (concat (first mut-line)
                          (pick (cmds (first mut-line))))))
          (drop (+ mut-point 1) asm)))))
#+end_src

** DONE fix issue with 20 scores
this is really just an issue with the shell scripts

now only reading the STDOUT (not STDERR) of the test-*.sh scripts

** DONE fix packaging up of results
the =mv= lines in the [[simple-gp-experiment]] aren't working
* COMMENT Util
  :PROPERTIES:
  :ID:       79ebc3e6-c662-4faf-b594-8db6cc16bf4e
  :END:

for copying tangled scripts over to pinyon

#+results: sync-dirs
| test |
| src  |
| lib  |

#+begin_src ruby :var dirs=sync-dirs :results silent
  dirs.each{|d| puts %x{rsync --progress -aruv #{d}/ pinyon:research/genprog/asm/#{d}} }
#+end_src

for pushing the new website up to pinyon
: rsync --progress -aruv --delete _asm-gp/ moons:public_html/research/asm-gp
